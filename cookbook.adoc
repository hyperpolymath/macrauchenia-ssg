// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell
= macrauchenia-ssg Cookbook
:toc: left
:toclevels: 4
:icons: font
:sectanchors:
:sectlinks:
:source-highlighter: rouge

== Overview

This cookbook provides comprehensive recipes, patterns, and command reference for working with macrauchenia-ssg - the Deno-based MCP adapter collection for 28+ static site generators.

=== Quick Links

* <<cli-reference,CLI Reference>>
* <<justfile-recipes,Justfile Recipes>>
* <<nickel-formulae,Nickel Formulae>>
* <<adapter-patterns,Adapter Patterns>>
* <<security-cookbook,Security Cookbook>>
* <<cicd-recipes,CI/CD Recipes>>

'''

[[cli-reference]]
== CLI Reference

This section documents all command-line interfaces and their combinations.

=== Deno Commands

==== Core Commands

[source,bash]
----
# Check all adapters for type errors
deno check adapters/*.js

# Run linter on adapters
deno lint adapters/

# Format all code
deno fmt adapters/

# Run tests
deno test --allow-read --allow-run tests/

# Run tests with coverage
deno test --coverage=coverage tests/
deno coverage coverage --lcov > coverage/lcov.info

# Generate documentation
deno doc --html --output=docs/api adapters/*.js
----

==== Task Runner

[source,bash]
----
# List available tasks
deno task

# Run specific tasks
deno task build      # Check syntax
deno task test       # Run unit tests
deno task lint       # Run linter
deno task fmt        # Format code
deno task ci         # Full CI pipeline
----

==== Adapter Execution

[source,bash]
----
# Run specific adapter
deno run --allow-all adapters/zola.js

# Import and test adapter in REPL
deno repl --allow-all
> const zola = await import("./adapters/zola.js")
> console.log(zola.name, zola.tools.length)
----

=== Git Commands

==== Branch Workflow

[source,bash]
----
# Create feature branch
git checkout -b feature/add-new-adapter

# Conventional commit
git commit -m "feat(adapter): add new SSG adapter"

# Push with tracking
git push -u origin feature/add-new-adapter
----

==== Security Scanning

[source,bash]
----
# Check for secrets in history
git log -p | grep -iE "(password|secret|api.?key)"

# Verify signed commits
git log --show-signature -3
----

=== Command Combinatorics

[cols="1,2,3", options="header"]
|===
|Base Command |Flags |Purpose

|`deno check`
|`--all`, `--config=deno.json`
|Type checking with full context

|`deno test`
|`--allow-read`, `--allow-run`, `--coverage=DIR`
|Test with permissions and coverage

|`deno lint`
|`--rules-include=no-eval`, `--json`
|Lint with specific rules, JSON output

|`deno fmt`
|`--check`, `--line-width=100`
|Format validation or modification
|===

'''

[[justfile-recipes]]
== Justfile Recipes

The `justfile` provides standardized build, test, and development commands.

=== Build Recipes

[source,bash]
----
# Check all adapters (default build)
just build

# Verbose build with full output
just build-verbose

# Clean all build artifacts
just clean
----

=== Test Recipes

[source,bash]
----
# Unit tests only
just test

# Tests with coverage report
just test-coverage

# End-to-end tests
just test-e2e

# All tests (unit + e2e)
just test-all

# Security-focused tests
just test-security
----

=== Development Workflow

[source,bash]
----
# Start development mode
just dev

# Open REPL with adapters
just repl

# Check environment
just env-check

# Show project info
just info
----

=== CI/CD Integration

[source,bash]
----
# Full CI pipeline (format + lint + test + build)
just ci

# Pre-commit checks
just pre-commit

# Prepare release
just release 0.3.0
----

=== Recipe Composition

[source,bash]
----
# Chain recipes
just clean build test

# Parallel execution (with xargs)
echo "lint test" | xargs -P2 -n1 just
----

'''

[[nickel-formulae]]
== Nickel Formulae

Nickel configuration patterns for type-safe SSG adapter definitions.

=== Adapter Schema

[source,nickel]
----
# adapters/schema.ncl
let AdapterSchema = {
  name : String,
  language : String,
  description : String,
  version : String | default = "1.0.0",

  connection : {
    binary_path : String,
    connect : { } -> Bool,
    disconnect : { } -> Unit,
  },

  tools : Array {
    name : String,
    description : String,
    inputSchema : {
      type : String,
      properties : { .. },
      required : Array String | default = [],
    },
    execute : { .. } -> {
      success : Bool,
      stdout : String,
      stderr : String,
      code : Number,
    },
  },
}

in AdapterSchema
----

=== Tool Definition Pattern

[source,nickel]
----
# Tool definition with input validation
let ValidatedTool = {
  name : String,
  description : String,

  inputSchema : {
    type = "object",
    properties : { .. },
    required : Array String | default = [],
  },

  # Input validators
  validators : {
    path : String -> String | PathValidator,
    port : Number -> Number | PortValidator,
    identifier : String -> String | IdentifierValidator,
  },

  execute : { .. } -> Result,
}
----

=== Configuration Merge

[source,nickel]
----
# Merge base config with adapter-specific config
let BaseConfig = import "./base.ncl"
let AdapterConfig = import "./zola.ncl"

BaseConfig & AdapterConfig & {
  # Override specific fields
  version = "2.0.0",
  security.strict_mode = true,
}
----

=== Validation Formulas

[source,nickel]
----
# Port validation formula
let PortValidator = fun port =>
  if port >= 1 && port <= 65535 then
    port
  else
    std.fail "Port must be between 1 and 65535"

# Path validation formula
let PathValidator = fun path =>
  if std.string.contains ".." path then
    std.fail "Path traversal not allowed"
  else if std.string.contains ";" path then
    std.fail "Shell metacharacters not allowed"
  else
    path

# Identifier validation formula
let IdentifierValidator = fun id =>
  let pattern = "^[a-zA-Z_][a-zA-Z0-9_]*$"
  if std.string.is_match pattern id then
    id
  else
    std.fail "Invalid identifier format"
----

'''

[[adapter-patterns]]
== Adapter Patterns

Canonical patterns for implementing secure SSG adapters.

=== Base Adapter Template

[source,javascript]
----
// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

export const name = "AdapterName";
export const language = "Language";
export const description = "Description of the SSG";

let connected = false;
let binaryPath = "binary-name";

// Security: Input validation
function sanitizeString(str) {
  if (typeof str !== "string") return "";
  if (/[;&|`$\n\r]/.test(str)) {
    throw new Error("Invalid characters");
  }
  return str;
}

function validatePath(path) {
  if (!path) return ".";
  const sanitized = sanitizeString(path);
  if (sanitized.includes("..")) {
    throw new Error("Path traversal not allowed");
  }
  return sanitized;
}

function validatePort(port) {
  const p = parseInt(port, 10);
  if (isNaN(p) || p < 1 || p > 65535) {
    throw new Error("Invalid port");
  }
  return p;
}

async function runCommand(args, cwd = null) {
  const cmd = new Deno.Command(binaryPath, {
    args,
    cwd: cwd || Deno.cwd(),
    stdout: "piped",
    stderr: "piped",
  });
  const output = await cmd.output();
  const decoder = new TextDecoder();
  return {
    success: output.success,
    stdout: decoder.decode(output.stdout),
    stderr: decoder.decode(output.stderr),
    code: output.code,
  };
}

export async function connect() {
  try {
    const result = await runCommand(["--version"]);
    connected = result.success;
    return connected;
  } catch {
    connected = false;
    return false;
  }
}

export async function disconnect() {
  connected = false;
}

export function isConnected() {
  return connected;
}

export const tools = [
  {
    name: "adapter_build",
    description: "Build the site",
    inputSchema: {
      type: "object",
      properties: {
        path: { type: "string", description: "Path to site root" },
      },
    },
    execute: async ({ path }) => {
      try {
        const safePath = validatePath(path);
        return await runCommand(["build"], safePath);
      } catch (e) {
        return { success: false, stdout: "", stderr: e.message, code: 1 };
      }
    },
  },
];
----

=== Code Injection Prevention

[cols="1,2,2", options="header"]
|===
|Language |Dangerous Characters |Safe Pattern

|Julia
|`; \` $ ( ) " \n \r`
|`sanitizeJuliaString(input)`

|Lisp
|`( ) " \` ' \\ ; # \|`
|`sanitizeLispString(input)`

|Tcl
|`[ ] $ \\ { } " ; \n \r`
|`sanitizeTclString(input)`

|Shell
|`; & \| \` $ ( ) \n \r`
|Use array args, never interpolate
|===

'''

[[security-cookbook]]
== Security Cookbook

Security patterns and best practices for adapter development.

=== Input Validation Matrix

[source,javascript]
----
// Validation function factory
const validators = {
  path: (p) => {
    if (!p) return ".";
    if (typeof p !== "string") throw new Error("Path must be string");
    if (p.includes("..")) throw new Error("Path traversal not allowed");
    if (/[;&|`$]/.test(p)) throw new Error("Invalid characters");
    return p;
  },

  port: (p) => {
    const num = parseInt(p, 10);
    if (isNaN(num) || num < 1 || num > 65535) {
      throw new Error("Invalid port");
    }
    return num;
  },

  identifier: (id) => {
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(id)) {
      throw new Error("Invalid identifier");
    }
    return id;
  },

  url: (u) => {
    if (!/^[a-zA-Z0-9._\-/:@]+$/.test(u)) {
      throw new Error("Invalid URL format");
    }
    return u;
  },
};
----

=== Secure Command Execution

[source,javascript]
----
// ALWAYS use array args, NEVER string interpolation
// BAD: exec(`${binary} ${userInput}`)
// GOOD: new Deno.Command(binary, { args: [userInput] })

async function safeExec(binary, args, cwd) {
  // Validate binary path
  if (!binary || binary.includes("/") && binary.includes("..")) {
    throw new Error("Invalid binary path");
  }

  // Use Deno.Command with array args
  const cmd = new Deno.Command(binary, {
    args: args.map(String), // Ensure all args are strings
    cwd: cwd || Deno.cwd(),
    stdout: "piped",
    stderr: "piped",
    // Don't inherit env - be explicit
    env: {
      PATH: Deno.env.get("PATH"),
      HOME: Deno.env.get("HOME"),
    },
  });

  return await cmd.output();
}
----

=== Security Checklist

[%interactive]
* [ ] No `eval()` or `Function()` usage
* [ ] No string interpolation in commands
* [ ] All user inputs validated
* [ ] Path traversal prevented
* [ ] Port numbers range-checked
* [ ] Identifiers regex-validated
* [ ] Error messages don't leak internals
* [ ] SPDX headers present
* [ ] No hardcoded secrets

'''

[[cicd-recipes]]
== CI/CD Recipes

GitHub Actions workflow patterns for macrauchenia-ssg.

=== Full CI Pipeline

[source,yaml]
----
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - run: deno lint adapters/

  fmt:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - run: deno fmt --check adapters/

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - run: deno test --allow-read --allow-run --coverage=coverage tests/
      - run: deno coverage coverage --lcov > coverage.lcov

  build:
    runs-on: ubuntu-latest
    needs: [lint, fmt, test]
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
      - uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x
      - run: deno check adapters/*.js
----

=== Release Workflow

[source,yaml]
----
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
      - uses: denoland/setup-deno@v2
      - run: deno task ci
      - uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
----

'''

== Appendix

=== Complete Command Matrix

[cols="1,1,2,1", options="header"]
|===
|Category |Command |Description |Example

|Build
|`just build`
|Check all adapters
|`just build`

|Test
|`just test`
|Run unit tests
|`just test`

|Test
|`just test-e2e`
|Run E2E tests
|`just test-e2e`

|Lint
|`just lint`
|Lint all code
|`just lint`

|Format
|`just fmt`
|Format all code
|`just fmt`

|CI
|`just ci`
|Full CI pipeline
|`just ci`

|Dev
|`just dev`
|Start dev mode
|`just dev`

|Info
|`just adapters`
|List adapters
|`just adapters`
|===

=== Environment Variables

[cols="1,2,1", options="header"]
|===
|Variable |Description |Default

|`DENO_DIR`
|Deno cache directory
|`~/.cache/deno`

|`NO_COLOR`
|Disable color output
|unset

|`DENO_JOBS`
|Parallel test jobs
|CPU count
|===
